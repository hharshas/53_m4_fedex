from typing import ClassVar

class Array2Di:
    def __init__(self, *args, **kwargs) -> None: ...
    def __buffer__(self, *args, **kwargs): ...
    def __release_buffer__(self, *args, **kwargs): ...

class Container:
    action_count: ClassVar[int] = ...  # read-only
    length: ClassVar[int] = ...  # read-only
    package_count: ClassVar[int] = ...  # read-only
    width: ClassVar[int] = ...  # read-only
    def __init__(self, height: int, packages: list[Package]) -> None: ...
    def serialize(self) -> str: ...
    def transition(self, action_idx: int) -> None: ...
    def unserialize(self) -> Container: ...
    @property
    def height(self) -> int: ...
    @property
    def height_map(self) -> Array2Di: ...
    @property
    def packages(self) -> list[Package]: ...
    @property
    def possible_actions(self) -> list[int]: ...
    @property
    def reward(self) -> float: ...

class Evaluation:
    action_idx: int
    container: Container
    priors: list[float]
    reward: float
    def __init__(self, *args, **kwargs) -> None: ...

class Package:
    cost: int
    is_placed: bool
    is_priority: bool
    pos: Vec3i
    shape: Vec3i
    weight: int
    def __init__(self) -> None: ...

class Vec3i:
    x: int
    y: int
    z: int
    def __init__(self, arg0: int, arg1: int, arg2: int) -> None: ...

def calculate_baseline_reward(container: Container, addresses: list[str]) -> float: ...
def generate_episode(container: Container, simulations_per_move: int, c_puct: float, virtual_loss: int, thread_count: int, batch_size: int, addresses: list[str]) -> list[Evaluation]: ...
